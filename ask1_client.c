/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
/* ΒΙΚΤΩΡ ΡΟΜΑΝΙΟΥΚ 713242017024 ΕΡΓ1 */

// To start ask1_client exec - ./ask1_client localhost
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include "ask1.h"

void error(char *msg)
{
	perror(msg);
	exit(1);
}
float find_m_1(char *host, float *array, int len)
{
	CLIENT *clnt;
	mo *result_1;
	mo find_1_arg;

#ifndef DEBUG
	clnt = clnt_create(host, FIND_M, FIND_VERS, "udp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */

	find_1_arg.b.b_val = (int *)malloc(len * sizeof(int));
	find_1_arg.b.b_len = len;
	find_1_arg.m = 0;
	for (int i = 0; i < len; i++)
	{
		find_1_arg.b.b_val[i] = array[i];
	}
	result_1 = find_1(&find_1_arg, clnt);
	if (result_1 == (mo *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	printf("Your result is : %f", result_1->m);
	return result_1->m;
#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */
}

float *find_min_max_1(char *host, float *array, int len, float *min_max_res)
{
	CLIENT *clnt;
	min_max *result_1;
	min_max find_mn_1_arg;
	min_max_res = (float *)malloc(2 * sizeof(float));

#ifndef DEBUG
	clnt = clnt_create(host, FIND_MIN_MAX, MIN_MAX_VERS, "udp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */
	find_mn_1_arg.b.b_val = (int *)malloc(len * sizeof(int));
	find_mn_1_arg.b.b_len = len;
	find_mn_1_arg.max, find_mn_1_arg.min = array[0];

	for (int i = 0; i < len; i++)
	{
		find_mn_1_arg.b.b_val[i] = array[i];
	}
	printf("CALLING RPC FUNCTION\n");
	result_1 = find_mn_1(&find_mn_1_arg, clnt);
	if (result_1 == (min_max *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	// printf("MIN IS : %d, MAX IS : %d", result_1->min, result_1->max);
	min_max_res[0] = result_1->min;
	min_max_res[1] = result_1->max;
	return min_max_res;
#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */
}

float *calc_ay_1(char *host, float *array, int len, int a, float *ay_res)
{
	CLIENT *clnt;
	ay *result_1;
	ay find_ay_1_arg;
	ay_res = (float *)malloc(len * sizeof(float));

#ifndef DEBUG
	clnt = clnt_create(host, CALC_AY, AY_VERS, "udp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */
	find_ay_1_arg.res.res_len = len;
	find_ay_1_arg.b.b_len = len;
	find_ay_1_arg.b.b_val = (int *)malloc(len * sizeof(int));
	// find_ay_1_arg.res.res_val = (float *)malloc(len * sizeof(float));
	find_ay_1_arg.a = a;
	for (int i = 0; i < len; i++)
	{
		find_ay_1_arg.b.b_val[i] = array[i];
	}
	result_1 = find_ay_1(&find_ay_1_arg, clnt);
	if (result_1 == (ay *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	for (int i = 0; i < len; i++)
	{
		ay_res[i] = result_1->res.res_val[i];
	}
	return ay_res;

#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */
}

int main(int argc, char *argv[])
{
	float op1_res;
	float *minmax;
	float a;
	float *ay;
	int op;
	int length;
	float data;
	float *p;
	int sockfd, newsockfd, portno, clilen, n, done;
	pid_t procId;
	char *host;
	struct sockaddr_in serv_addr, cli_addr;
	unsigned int children = 0;

	/*if (argc < 2)
	{
		printf("usage: %s server_host\n", argv[0]);
		fprintf(stderr, "ERROR, NO PORT PROVIDED\n");
		exit(1);
	*/
	//}
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0)
		error("ERROR opening socket");
	bzero((char *)&serv_addr, sizeof(serv_addr));
	portno = 65530; // This is our port
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(portno);
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	if (bind(sockfd, (struct sockaddr *)&serv_addr,
			 sizeof(serv_addr)) < 0)
		error("ERROR on binding");

	listen(sockfd, 5);
	for (;;)
	{
		printf("Waiting for a connection...\n");
		clilen = sizeof(cli_addr);
		newsockfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen);
		if (newsockfd < 0)
			error("ERROR on accept");

		if (fork() == 0)
		{ // child process
			close(sockfd);
			printf("Connected.\n");
			done = 0;
			do
			{
				recv(newsockfd, &op, sizeof(op), 0);
				printf("OPERATION %d SELECTED\n", op);
				recv(newsockfd, &length, sizeof(length), 0);
				recv(newsockfd, &a, sizeof(a), 0);
				printf("SIZE OF ARRAY WILL BE : %d \n", length);
				printf("A Num : %f\n", a);
				printf("DYNAMIC MEMORY ALLOCATION\n");
				p = (float *)malloc(length * sizeof(float));
				for (int i = 0; i < length; i++)
				{
					recv(newsockfd, &data, sizeof(data), 0);
					p[i] = data;
					printf("ARRAY INDEX %d HAS VALUE %f \n", i, p[i]);
				}
				recv(newsockfd, &minmax, sizeof(minmax), 0);
				host = argv[1];
				if (op == 1)
				{
					op1_res = find_m_1(host, p, length);
					send(newsockfd, &op1_res, sizeof(op1_res), 0);
				}
				else if (op == 2)
				{
					minmax = find_min_max_1(host, p, length, minmax);
					printf("MIN : %f MAX : %f", minmax[0], minmax[1]);
					for (int i = 0; i < 2; i++)
					{
						send(newsockfd, &minmax[i], sizeof(minmax) * 2, 0); // We use sizeof() * 2 number of elements becaues array is dynamically allocated
					}
				}
				else if (op == 3)
				{
					ay = calc_ay_1(host, p, length, a, ay);
					printf("CALCULTED AY ARRAY\n");
					for (int i = 0; i < length; i++)
					{
						printf("VALUE [%d] IS %f\n", i, ay[i]);
						send(newsockfd, &ay[i], sizeof(ay) * length, 0); // We use sizeof() * 2 number of elements becaues array is dynamically allocated
					}
				}
				else
				{
					printf("Wrong Operation!\n");
				}
				exit(0);
				done = 1;
			} while (!done);
			exit(0);
		}
		close(newsockfd);
		children++;
		while (children)
		{
			procId = waitpid((pid_t)-1, NULL, WNOHANG);
			if (procId < 0)
				error("WATIPID ERROR");
			else if (procId == 0)
				break;
			else
				printf("COLLECTED");
		}
	}
}
